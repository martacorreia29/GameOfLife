world : World
world = Tile 0 True ((Tile 1 True (Tile 2 False (Tile 3 False Nil))))

data Game = Size Int | RowSize Int | WordList World 
data World = Nil | Tile Int Bool World

type TileChannel : SL = 
	&{ Index : !Int; TileChannel,
       State : !Bool; TileChannel,
       Next  : WorldChannel; TileChannel,
	   Exit  : Skip
	}

type WorldChannel : SL = 
	+{ Tile: TileChannel,
       Nil : Skip
  	}

type GameChannel : SL =
	+{ Size : !Int,
       RowSize: !Int, 
       World : WorldChannel,
       Exit : Skip
    }

client : forall a:SL => GameChannel; a -> Game -> a
client c game = 
	case game of {
      Size size ->
     	let (m,c) =	select Size in send m c,
      RowSize rowsize -> 
      	(send rowsize c),
      WordList world ->
      	clientWorld[a] (select World c) world
    }

clientWorld : forall a:SL => WorldChannel; a -> World -> a
clientWorld c world = 
	case world of {
      Nil ->
      	select Nil c,
      Tile index state next ->
      	clientTile[a] (select Tile c) index state next
      }

clientTile : forall a:SL => TileChannel; a -> Int -> Bool -> World -> a
clientTile c index state next = 
	match c with {
      Index c ->
      	clientTile[a] (send index c) index state next,
      State c ->
        clientTile[a] (send state c) index state next,    
      Next c -> 
      	let c = clientWorld[TileChannel;a] c next in
      	clientTile[a] c index state next,
	  Exit c ->
      	c
    }
      
server : forall a:SL => dualof GameChannel; a -> Int -> Int -> World -> a
server s size rowSize world =
	match s with {
       Size s ->
      		let (newSize, s) = receive s in
       		server[a] s newSize rowsize world,
       RowSize s ->
      		let (newRowSize, s) = receive s in
       		server[dualof WorldChannel;a] s newRowSize rowsize world,
       World s ->
      		serverWorld[a] s size rowSize world 
   }

serverWorld : forall a:SL => dualof WorldChannel; a -> Int -> Bool -> a
serverWorld s index state = 
	match s	with {
      Nil s -> 
      	s,
      Tile s ->
      	serverTile[a] s index state
    }

serverTile : forall a:SL => dualof TileChannel; a -> Int -> Bool -> a
--serverTile c index state = 
	

main : ()
main =
  let (c, s) = new GameChannel in
  fork (sink (client[Skip] c world));
  sink (server s)

sink : Skip -> ()
sink _ = ()
